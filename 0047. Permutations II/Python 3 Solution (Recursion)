'''
Link to original problem:
https://leetcode.com/problems/permutations-ii/

Given a collection of numbers, nums, that might contain duplicates, 
return all possible unique permutations in any order.
'''

'''
Intuition:
This problem can be solved by adding a single line to our recursive 
solution for Problem 46. Permutations.  Consider, if the ith value and
the i+1th value are the same, if then the sub-array generated by these
two iterations of our loop will be identical.  Thus, we should skip 
these to only return unique permutations. 
'''

class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        
        if len(nums) == 0:
            return []
        if len(nums) == 1:
            return [nums]
        
        # We also need to sort our list for our method to work
        nums.sort()
        permutations = []
        for i in range(len(nums)):
            # We added this line to remove duplicates
            if i>=1 and nums[i]==nums[i-1]:
                continue
            not_i = nums.copy()
            not_i.pop(i)
            permutations_i = self.permuteUnique(not_i)
            for permutation_i in permutations_i:
                permutations.append([nums[i]] + permutation_i)
        return permutations
